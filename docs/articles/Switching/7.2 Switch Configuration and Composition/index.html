<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/IcarusSong/cxl-introduction.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">7.2 Switch Configuration and Composition</a><ul><li><a href="#h2-1">7.2.1 CXL 交换机初始化选项</a><ul><li><a href="#h3-2">静态初始化 (Static Initialization)</a></li></ul><ul><li><a href="#h3-3">Fabric Manager (FM) 优先启动</a></li></ul><ul><li><a href="#h3-4">Fabric Manager (FM) 和主机同时启动</a></li></ul></li></ul><ul><li><a href="#h2-5">7.2.3 绑定和解绑 (Binding and Unbinding)</a><ul><li><a href="#h3-6">1. 单一逻辑设备端口的绑定与解绑 (Binding and Unbinding of a Single Logical Device Port)</a></li></ul><ul><li><a href="#h3-7">2. 池化设备 (MLD) 的绑定与解绑 (Binding and Unbinding of a Pooled Device)</a></li></ul></li></ul><ul><li><a href="#h2-8">7.2.4 PPB and vPPB Behavior for MLD Ports</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">7.2 Switch Configuration and Composition</h1><h2 id="h2-1">7.2.1 CXL 交换机初始化选项</h2><p>CXL交换机可以使用三种不同的方法进行初始化，分别是：</p><ul><li>静态初始化 (Static Initialization)</li></ul><ul><li>Fabric Manager (FM) 优先启动</li></ul><ul><li>Fabric Manager (FM) 和主机同时启动</li></ul><h3 id="h3-2">静态初始化 (Static Initialization)</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6863710b58cb8da5c8820bc4.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6863710b58cb8da5c8820bc4.png" alt=""></a> 图中展示了一个静态初始化的 CXL 交换机，它带有 2 个 VCS。在这个例子中，下游的 vPPB 被静态绑定到端口，并且在启动时对主机可用。支持使用标准的 PCIe 机制来对设备进行托管式的热插拔。 <b>核心理念</b>：</p><ul><li>交换机的配置是预先定义好并且固定的。在交换机启动时，所有的虚拟CXL交换机 (VCSs) 和下行端口的绑定关系都是通过厂商定义的机制（例如，从一个 SPI Flash 芯片中加载配置文件）静态配置好的。</li></ul><p><b>特点与限制</b>：</p><ul><li>无需 Fabric Manager (FM)：这种模式完全不需要 FM 的参与。</li></ul><ul><li>行为类似 PCIe 交换机：VCS 的行为和功能与一个标准的 PCIe 交换机非常相似，只是额外增加了对 CXL 协议的支持。</li></ul><ul><li>主机即时可用：当主机系统启动时，每个 VCS 都已经配置完毕，可以立即被主机发现和枚举。</li></ul><ul><li>不支持动态配置：不支持多逻辑设备 (MLD) 端口，也不支持在运行时将端口重新绑定到不同的 VCS。</li></ul><ul><li>支持热插拔：支持通过标准的 PCIe 机制对设备进行管理型热添加 (managed hot-add) 和热移除。</li></ul><ul><li>支持RCD、CXL VH、PCIe 模式</li></ul><h3 id="h3-3">Fabric Manager (FM) 优先启动</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6863727f58cb8da5c8821bc1.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6863727f58cb8da5c8821bc1.png" alt=""></a> <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/686372d658cb8da5c8821f61.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/686372d658cb8da5c8821f61.png" alt=""></a> 启动流程：</p><ol start="1"><li>FM 启动，主机复位：FM 首先启动，而主机则被保持在复位状态。</li></ol><ol start="2"><li>端口链路建立：交换机所有连接的下行端口 (DSPs) 建立链路，并初始绑定到由 FM 所拥有的物理 PCI-to-PCI 桥 (PPBs) 上。</li></ol><ol start="3"><li>FM 执行绑定：FM 通过其管理接口向交换机发送绑定命令（例如 <code>BIND (VCSO, VPPB1, PHY_PORT_ID1)</code>），指示交换机将一个指定的物理端口绑定到一个特定 VCS 中的虚拟 PPB (vPPB) 上。</li></ol><ol start="4"><li>交换机完成映射：交换机执行从虚拟到物理的绑定，将 vPPB 的虚拟端口号映射到物理端口号 ，并将 vPPB 的所有功能（如链路控制）直接映射到该物理端口上。此时，原先由 FM 拥有的 PPB 对于该端口来说就不存在了。</li></ol><ol start="5"><li>主机启动：当主机被解除复位并启动时，交换机已经完全配置好，主机可以正常进行设备枚举。</li></ol><h3 id="h3-4">Fabric Manager (FM) 和主机同时启动</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/686373fe58cb8da5c88232fb.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/686373fe58cb8da5c88232fb.png" alt=""></a> <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6863762058cb8da5c8824b89.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6863762058cb8da5c8824b89.png" alt=""></a></p><ul><li>核心理念：主机先发现一个“空的”虚拟交换机结构，然后由 FM 在后台进行设备发现和绑定，并通过热添加的方式通知主机。</li></ul><ul><li>启动流程：<ul><li>静态定义 VCS：交换机内的 VCS 结构是静态定义好的。</li></ul><ul><li>vPPB 初始为未绑定：每个 VCS 内的下行 vPPB 初始时都是未绑定的，并向主机呈现为“链路关闭 (Link Down)”的状态。</li></ul><ul><li>主机和 FM 同时工作：主机启动后会枚举到这个虚拟层次结构 (VH)。同时，交换机发现其下行端口连接的设备，并将这些设备信息呈现给 FM。</li></ul><ul><li>FM 执行绑定：FM 根据策略，执行将物理端口（设备）绑定到 vPPB 的操作。</li></ul><ul><li>热添加通知：每当一个端口成功绑定，交换机就会向对应的主机发送一个热添加 (hot-add) 的通知，主机就像发现一个新插入的设备一样去配置和使用它。</li></ul></li></ul><h2 id="h2-5">7.2.3 绑定和解绑 (Binding and Unbinding)</h2><p>这部分是 CXL 交换机实现动态资源分配的核心机制。它描述了如何将一个物理端口（及其连接的设备）与一个虚拟层次结构中的 vPPB 关联（绑定）或分离（解绑）的过程。这个过程根据设备是单一逻辑设备 (SLD) 还是多逻辑设备 (MLD) 而有所不同。</p><h3 id="h3-6"><ol start="1"><li>单一逻辑设备端口的绑定与解绑 (Binding and Unbinding of a Single Logical Device Port)</li></ol></h3><p>一个 SLD 端口一次只能绑定到一个 VCS。它可以连接 PCIe 设备或 CXL Type 1, 2, 3 型的 SLD 设备。</p><ul><li><b>绑定 (Binding)</b>:<ul><li><b>未绑定状态</b>: 当一个 vPPB 未绑定到任何物理端口时，它对主机来说就像一个处于“链路关闭”(Link Down) 且无设备存在 (No Presence Detect) 的状态。</li></ul><ul><li><b>绑定过程</b>: 如果需要重新绑定，必须有一个 Fabric Manager (FM)。FM 可以发出命令，将一个未使用的物理端口绑定到一个未绑定的 vPPB 上。绑定后，vPPB 的所有端口设置都会应用到该物理端口。对于主机而言，这个过程看起来就像一个设备被热添加到系统中。</li></ul></li></ul><ul><li><b>解绑 (Unbinding)</b>:<ul><li><b>解绑过程</b>: FM 向交换机发送一个针对特定 vPPB 的解绑命令。</li></ul><ul><li><b>交换机动作</b>: 交换机收到命令后，会对该物理端口置位“链路禁用”(Link Disable)，使链路断开。</li></ul><ul><li><b>端口归属</b>: 解绑后，该物理端口变为“FM 拥有的”(FM-owned)，并由该物理端口的 PPB 设置来控制。</li></ul><ul><li><b>准备重绑</b>: FM 可以通过其 API 对这个由它拥有的端口进行 CXL.io 访问，例如触发功能级复位 (FLR) 或 CXL 复位，为下一次绑定做准备。</li></ul></li></ul><p><b>流程示意 (参考图 7-9 至 7-11)</b>: <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6863790d58cb8da5c882575b.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6863790d58cb8da5c882575b.png" alt=""></a> <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6863792858cb8da5c8825770.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6863792858cb8da5c8825770.png" alt=""></a> <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6863793858cb8da5c8825787.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6863793858cb8da5c8825787.png" alt=""></a></p><ol start="1"><li>初始状态：VCS 0 的 vPPB 2 绑定到某个物理端口。</li></ol><ol start="2"><li>FM 发出解绑命令给 VCS 0 的 vPPB 2。</li></ol><ol start="3"><li>该物理端口变为未绑定状态，由 FM 拥有的 PPB 控制。</li></ol><ol start="4"><li>FM 可以再发出绑定命令，将这个空闲的物理端口绑定到另一个虚拟交换机（例如 VCS 1 的 vPPB 1）。</li></ol><ol start="5"><li>绑定成功后，交换机会向 Host 1 发送一个热添加通知。</li></ol><h3 id="h3-7"><ol start="2"><li>池化设备 (MLD) 的绑定与解绑 (Binding and Unbinding of a Pooled Device)</li></ol></h3><p>池化设备（即 MLD）在一个物理端口上包含多个逻辑设备 (LDs)，因此其流量可以与多个分属于不同 VCS 的 vPPB 相关联。其绑定和解绑过程与 SLD 类似，但有几个<b>关键区别</b>：</p><ol start="1"><li><b>不影响物理链路</b>: 绑定或解绑 MLD 中的某个 LD <b>绝不能</b>影响物理链路本身（例如，不能使用 PERST# 复位、热复位或禁用链路），也必须不影响其他 VCS 的流量。</li></ol><ol start="2"><li><b>物理 PPB 始终由 FM 拥有</b>: MLD 端口的物理 PPB <b>始终</b>归 FM 所有。FM 负责该物理端口的链路控制、错误处理等。</li></ol><ol start="3"><li><b>由 FM 管理设备</b>: FM 可能需要管理池化设备以更改内存分配、启用 LD 等。</li></ol><p><b>流程示意 (参考图 7-12 至 7-14)</b>: <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/68637a9058cb8da5c8825ac3.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/68637a9058cb8da5c8825ac3.png" alt=""></a></p><ol start="1"><li><b>初始状态</b>: MLD 设备连接到交换机，交换机在链路建立后通知 FM 这是一个 Type 3 池化设备。此时 MLD 中的各个 LD (如 LD 0, LD 1) 处于未绑定状态。</li></ol><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/68637ab858cb8da5c8825bc4.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/68637ab858cb8da5c8825bc4.png" alt=""></a></p><ol start="1"><li><b>配置并绑定第一个 LD</b>: FM 通过其 API 配置池化设备中的 LD 1（例如设置内存分配）。然后，FM 发送绑定命令，将 VCS 0 中未绑定的 vPPB 2 与该池化设备的 LD 1 进行绑定。</li></ol><ol start="2"><li><b>交换机设置路由</b>: 交换机执行虚拟到物理的转换，确保所有目标为 VCS 0 的 vPPB 2 的 CXL.io 和 CXL.mem 流量都被路由到 MLD 端口，并附上 LD-ID=1。</li></ol><ol start="3"><li><b>热添加通知</b>: 绑定后，该 vPPB 会像 SLD 绑定一样，向 VCS 0 的主机通知一个热添加事件。</li></ol><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/68637b2b58cb8da5c882602f.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/68637b2b58cb8da5c882602f.png" alt=""></a></p><ol start="4"><li><b>绑定第二个 LD 到不同主机</b>: 同样地，FM 可以配置 LD 0，并将其绑定到另一个虚拟交换机，例如 VCS 1 中的 vPPB 1。这样，同一个 MLD 设备的不同逻辑部分（内存）就可以同时被 Host 0 和 Host 1 访问。</li></ol><h2 id="h2-8">7.2.4 PPB and vPPB Behavior for MLD Ports</h2><ul><li>核心思想是：一个 MLD 端口是一个共享的物理接口，多个 vPPB（代表不同的主机或虚拟层次）可以同时通过这个共享接口访问 MLD 中的不同逻辑设备 (LDs) 。因此，必须对控制进行区分：<ul><li>物理层控制必须统一：所有与物理链路直接相关的操作（如链路速度、复位、链路训练等）必须由一个统一的实体来管理，不能由某个主机单独控制。</li></ul><ul><li>逻辑层控制可以虚拟化：每个主机（通过其 vPPB）应该能独立控制与自己相关的逻辑功能（如错误报告的屏蔽、总线主控使能等）。</li></ul></li></ul><ul><li>为了实现这一点，CXL 定义了两种不同的角色，这些角色在后续的表格 (7-2 到 7-11) 中作为两列进行对比：<ul><li>FM-owned PPB (由 FM 拥有的 PPB)：这代表了控制真实物理端口的那个唯一的、物理的 PPB 。它由 Fabric Manager (FM) 管理，负责所有物理链路层面的控制、配置和错误处理 。</li></ul><ul><li>All Other vPPBs / All vPPBs Bound to the MLD Port (所有其他/绑定到 MLD 端口的 vPPB)：这些是暴露给各个主机的虚拟 PPB 。每个主机看到并配置的是自己的 vPPB，但这些 vPPB 无法直接控制共享的物理链路。</li></ul></li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/reference" >reference</a></li></ul><ul><li><a href="../../md-docs/CXL_System_Architecture" >CXL_System_Architecture</a></li></ul><ul><li><a href="../../CXL简介/CXL初认识" >CXL简介</a><ul><li><a href="../../CXL简介/CXL初认识" >CXL初认识</a></li></ul><ul><li><a href="../../CXL简介/CXL子协议" >CXL子协议</a></li></ul><ul><li><a href="../../CXL简介/CXL2.0介绍" >CXL2.0介绍</a></li></ul><ul><li><a href="../../CXL简介/CXL3.0介绍" >CXL3.0介绍</a></li></ul><ul><li><a href="../../CXL简介/CXL3.1和CXL3.2" >CXL3.1和CXL3.2</a></li></ul></li></ul><ul><li><a href="../../CXL_Transaction_Layer/CXL.io" >CXL_Transaction_Layer</a><ul><li><a href="../../CXL_Transaction_Layer/CXL.io" >CXL.io</a></li></ul><ul><li><a href="../../CXL_Transaction_Layer/CXL.mem" >CXL.mem</a></li></ul><ul><li><a href="../../CXL_Transaction_Layer/CXL.cache" >CXL.cache</a></li></ul><ul><li><a href="../../CXL_Transaction_Layer/Transaction_Ordering_Summary" >Transaction_Ordering_Summary</a></li></ul><ul><li><a href="../../CXL_Transaction_Layer/Transaction Flows to Device-attached Memory" >Transaction Flows to Device-attached Memory</a></li></ul></li></ul><ul><li><a href="../../Switching/Overview" >Switching</a><ul><li><a href="../../Switching/Overview" >Overview</a></li></ul><ul><li><a href="../../Switching/7.2 Switch Configuration and Composition" >7.2 Switch Configuration and Composition</a></li></ul><ul><li><a href="../../Switching/7.3 CXL.io, CXL.cachemem Decode and Forwarding" >7.3 CXL.io, CXL.cachemem Decode and Forwarding</a></li></ul><ul><li><a href="../../Switching/7.6 Fabric Manager Application Programming Interface" >7.6 Fabric Manager Application Programming Interface</a></li></ul><ul><li><a href="../../Switching/7.7 CXL Fabric Architecture" >7.7 CXL Fabric Architecture</a></li></ul></li></ul><ul><li><a href="../../spec9.0/9.1 CXL Boot and Reset Overview" >spec9.0</a><ul><li><a href="../../spec9.0/9.1 CXL Boot and Reset Overview" >9.1 CXL Boot and Reset Overview</a></li></ul><ul><li><a href="../../spec9.0/9.5 Function Level Reset (FLR)" >9.5 Function Level Reset (FLR)</a></li></ul><ul><li><a href="../../spec9.0/9.6 Cache Management" >9.6 Cache Management</a></li></ul><ul><li><a href="../../spec9.0/9.7 CXL Reset" >9.7 CXL Reset</a></li></ul><ul><li><a href="../../spec9.0/9.9 Hot-Plug" >9.9 Hot-Plug</a></li></ul><ul><li><a href="../../spec9.0/9.11 RCD Enumeration" >9.11 RCD Enumeration</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../Switching/Overview","../../Switching/7.3 CXL.io, CXL.cachemem Decode and Forwarding","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>