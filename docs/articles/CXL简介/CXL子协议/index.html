<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/IcarusSong/cxl-introduction.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">CXL子协议</a><ul><li><a href="#h2-1">CXL.io</a></li></ul><ul><li><a href="#h2-2">CXL.cache</a><ul><li><a href="#h3-3">D2H request</a></li></ul><ul><li><a href="#h3-4">H2D request</a></li></ul><ul><li><a href="#h3-5">H2D response</a></li></ul><ul><li><a href="#h3-6">D2H response</a></li></ul><ul><li><a href="#h3-7">example</a><ul><li><a href="#h4-8">Read</a></li></ul><ul><li><a href="#h4-9">Write</a></li></ul><ul><li><a href="#h4-10">Read0-Write</a></li></ul></li></ul></li></ul><ul><li><a href="#h2-11">CXL.mem</a><ul><li><a href="#h3-12">协议通道和消息类型</a></li></ul><ul><li><a href="#h3-13">HDM-H</a><ul><li><a href="#h4-14">Read from Host</a></li></ul><ul><li><a href="#h4-15">Write from Host</a></li></ul></li></ul><ul><li><a href="#h3-16">HDM-D</a><ul><li><a href="#h4-17">Read from Host</a></li></ul><ul><li><a href="#h4-18">Write from Host</a></li></ul><ul><li><a href="#h4-19">Device Read to Device Memory</a></li></ul><ul><li><a href="#h4-20">设备发起的写操作</a></li></ul></li></ul></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">CXL子协议</h1><h2 id="h2-1">CXL.io</h2><ul><li><b>继承性</b>：CXL.io 直接基于 PCIe 5.0 的物理层和链路层，兼容其电气特性与基础协议栈。</li></ul><ul><li><b>扩展功能</b>：在 PCIe 基础上，CXL.io 增加了对 CXL 设备（如加速器、内存扩展卡）的发现、配置和高效 I/O 虚拟化的支持。</li></ul><ul><li><b>定位</b>：CXL.io 是 CXL 协议的“基础层”，与 CXL.cache（缓存一致性）和 CXL.mem（内存访问）共同构成完整的 CXL 协议栈</li></ul><h2 id="h2-2">CXL.cache</h2><ul><li>CXL.cache允许<b>device缓存host的主存</b>，并且规定CXL device中的cache使用<b>MESI</b>协议来维护cache coherent</li></ul><ul><li>CXL.cache实现的是<b>非对称一致性协议(目录协议)</b>，host中集成一个home agent，由host统一管理所有device的缓存一致性。所以CXL设备不需要直接与任何同级缓存交互，而只需要跟Home Agent交互。其中Home Agent通过发送Snoop请求给同级缓存进行一致性的维护，为了减少不必要的一致性流量，Home Agent会实现一个叫Snoop Filter的结构。</li></ul><ul><li>CXL.cache所有请求地址都是host的<b>物理地址</b>，在CXL设备中可以实现一个DTLB来加快地址翻译过程，DTLB的表项可以通过PCIe提供的地址翻译服务（ATS）向主机进行请求。</li></ul><ul><li>CXL.cache传输的<b>数据粒度始终为64B</b></li></ul><p>CXL.cache是一个双向cache一致性协议，分为两个方向：<b>D2H，H2D</b>。每个方向上又有三个通道：<b>Request、Response以及Data</b>。</p><h3 id="h3-3">D2H request</h3><p>D2H Request一共有15条commands，可以分为4类：<b>Read、Read0、Read0-Write以及Write。</b></p><ul><li><b>Read：进行读操作，需要最新的数据</b><ul><li>RdCurr：获取数据后不缓存。</li></ul><ul><li>RdOwn：读数据同时获取独占的权限</li></ul><ul><li>RdShared：只是读数据，不获取独占权限</li></ul><ul><li>RdAny：获取数据后可以是任何状态，默认是缓存的</li></ul></li></ul><ul><li><b>Read0：发送读请求但是不需要数据，仅仅请求获得cache line一致性状态</b><ul><li>RdOwnNoData：已经有数据，但是需要获取独占的权限</li></ul><ul><li>CLFlush：无效同级的缓存行，如果是脏数据在无效前先写回</li></ul><ul><li>CacheFlushed：表示一种确认，自己缓存行已经完成冲刷，用于帮助Home Agent更新Snoop Filter</li></ul></li></ul><ul><li><b>Read0-Write：允许Device在发出请求之前无需任何一致性状态，即可直接向Host写入数据（原子性操作，先获取独占权限（Read0）再写入数据（Write），合并为单次请求。</b>）。<ul><li>ItoMWr：Home Agent收到请求后首先获取写权限，不需要传递最新的数据给CXL Device，因为接着CXL设备会对整个缓存行进行写入，写完后CXL设备还是处于I状态</li></ul><ul><li>WrCur(CXL3.0更名)/MemWr(旧名字)：跟ItoMWr一样，CXL设备只负责提供写入的数据，不会缓存数据。跟ItoMWr不一样的地方是CXL提供的数据写入的位置。MemWr只有在缓存命中的时候才会写入到缓存中，否则直接写到内存中。而ItoMWr只要在memory之前有缓存层级，不管是否命中，都会写到缓存中，而不会写到内存中去。</li></ul></li></ul><ul><li><b>Write：将数据写回Host，同时将Device中对应的cache line状态设置为I</b>。<ul><li>CleanEvict和DirtyEvict都是将自己的数据写到Host中，自己无效掉；</li></ul><ul><li>CleanEvictNoData：不会向host发送数据，只需要通知Host自己静默驱逐啦，让Host修改snoop Filter的表项。</li></ul><ul><li>WOWrInv: weakly order 部分写，它的响应是FastGO（Global Observation），不提供GO语义；（Home Agent收到WOWrInv请求后，不用等维护一致性所有的Snoop请求全部收到响应，就可以发送FastGo+WritePull组合响应给CXL设备侧，即这个时候并不保证写全局可见，但是可以更快地完成写请求。如果需要全局可见，需要等到最后收到了ExtCmp消息）</li></ul><ul><li>WOWrInvF：weakly order 整个缓存行写入</li></ul><ul><li>WrInv：strong order 写(不区分是否整行写入，最后还会收到Go_I表示全局可见)</li></ul></li></ul><h3 id="h3-4">H2D request</h3><p><b>H2D 请求通道用于主机更改设备中的缓存一致性状态</b>，这被称为“<b>Snooping”（缩写为 Snp）</b>。设备必须根据 Snoop 类型更新其缓存，并且在缓存中有脏数据（M 状态）的情况下，还必须将数据返回给主机。 H2D Request消息由三种：<b>SnpData、SnpInv、SnpData</b></p><ul><li>SnpData<ul><li><b>缓存状态降级为共享状态，但必须返回任何修改的数据</b></li></ul><ul><li>这些是来自主机的对要缓存的行的 snoop 请求, 这些缓存行打算在请求者是 Shared 或 Exclusive 状态（Exclusive 状态可以缓存在仅当所有设备都以 RspI 响应时的请求者）。 这种类型的 snoop 通常是由数据读取请求触发。 接收此侦听的设备必须要么使所有缓存行无效或降级为共享状态。 如果设备持有脏数据必须归还给Host</li></ul></li></ul><ul><li>SnpInv<ul><li><b>缓存行降级为无效，必须返回任何修改的数据</b></li></ul><ul><li>这些是来自主机的对打算授予所有权的缓存行的 snoop 请求，缓存行在请求者中是独占状态。专门为Write类请求服务，获取缓存行独占权限。接收此监听的设备必须使所有高速缓存行无效。 如果设备持有脏数据，它必须将其返回给主机。</li></ul></li></ul><ul><li>SnpCur<ul><li><b>缓存状态不变，必须返回任何修改的数据</b></li></ul><ul><li>这个 snoop 获取缓存行的当前版本，但不需要更改任何缓存层次结构中的状态。它仅为了 RdCurr 请求发送。如果设备保存处于修改状态的数据，它必须将其返回给主机。 缓存状态可以保持设备和主机都没有变化，主机不应该更新它的缓存。</li></ul></li></ul><h3 id="h3-5">H2D response</h3><ul><li><p>WritePull</p><ul><li><p><b>WritePull 专门为WrInv/WrCur设计的，让CXL设备提供需要写入的数据，当前的请求交易还没有结束；Host接收数据写入后再发送Go-I表示事务完成，全局可见。</b></p></li></ul></li></ul><ul><li><p>GO</p><ul><li><p><b>全局观察（GO）消息表明读请求是连贯的，写请求是连贯且一致的。Go表示读或者写请求已经全局可见；并且可以携带MESI的状态，即CXL设备的缓存应该处于的状态。</b></p></li></ul></li></ul><ul><li>GO_WritePull<ul><li><b>这是一个组合的 GO + WritePull 消息。 不携带MESI状态消息；主要用于不需要后续再发送一个Go消息来确认写入的数据已经全局可见的写请求。（比如CleanEvict或者DirtyEvict）</b></li></ul></li></ul><ul><li>ExtCmp<ul><li>这个响应<b>表明之前本地排序的数据（FastGO）有在整个系统中已经被观察</b>。 最重要的是，对内存的访问将返回最新的数据。</li></ul></li></ul><ul><li>GO_WritePull_Drop<ul><li>此消息与 Go_WritePull 具有相同的语义，除了设备应该不向主机发送数据。</li></ul></li></ul><ul><li>Fast_GO_WritePull<ul><li>类似于GO_WritePull，但仅表示该请求在本地被观察到。当事务在内存中完全可观察时，稍后会发送ExtCmp消息。未实现Fast_GO功能的设备可以忽略GO消息并等待ExtCMP。对于WritePull，必须始终发送数据。不会将缓存状态传输到设备。</li></ul><ul><li>在本上下文中，“本地观察”是指特定于主机的相干域，它可能是全局相干域的子集。例如，请求设备与其他CXL.cache设备共享的末级缓存（Last Level Cache），这些设备连接在主机桥下方。在该示例中，本地观察仅在末级缓存内进行，而不是在其他末级缓存之间。</li></ul></li></ul><ul><li>GO_ERR_WritePull<ul><li>跟GO_WritePull拥有类似的语义，代表事务出现了错误，CXL设备还是需要提供数据，但是主机会丢弃这个数据</li></ul></li></ul><h3 id="h3-6">D2H response</h3><p>device在收到Host发来的H2D Request后，进行应答，发送D2H Response。 D2H Response消息共有七种，D2H Response 的 Opcode 的名字格式很有规律，<b>Rsp+X+Hit/Fwd+Y</b>，X 表示新的缓存行状态，Y 是原来的缓存行状态，Hit 不附带数据，Fwd 附带数据</p><ul><li>X、Y可以为V、SE、M、I、其中V代表MESI种MES三种状态。</li></ul><ul><li>RspXHitY ：CXL设备在Y状态下命中，同时响应后处于X状态；</li></ul><ul><li>RspS(I)FwdM ： 表示CXL设备的缓存之前是M状态，后续变成了S/I，并随后会把数据传给Host</li></ul><ul><li>RspVFwdV ：表示CXL设备缓存之前的状态是M/E，后续保存不变，同时会把数据传给Host；</li></ul><h3 id="h3-7">example</h3><p>缓存一致性所涉及的内存层次结构： <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6862204e58cb8da5c87ed17e.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6862204e58cb8da5c87ed17e.png" alt=""></a></p><p>这里的Peer Cache可以是下面任意一种：</p><ul><li>CXL的邻居设备</li></ul><ul><li>本CPU中的cache</li></ul><ul><li>远端CPU中的cache</li></ul><p>这里的内存控制器也可以是各种内存：</p><ul><li>本CPU的传统DDR</li></ul><ul><li>远端CPU的传统DDR</li></ul><ul><li>邻居CXL设备上的CXL.mem</li></ul><h4 id="h4-8">Read</h4><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6862205f58cb8da5c87ed1f4.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6862205f58cb8da5c87ed1f4.png" alt=""></a></p><ul><li><b>CXL设备在D2H的Req通道发送RdShare给Home Agent用于读数据</b>。Home Agent一般会有snoop filter，记录着哪些peer cache可能有这个数据的副本。<b>home agent接收到RdShared后一边在H2D的Req通道发送SnpData嗅探请求给有数据的peer cache，一边向内存发送读请求</b>。</li></ul><ul><li><b>peer cache接受到SnpData请求后</b>，并没有传递数据，而是<b>在D2H的Resp通道返回了RspSHitSE</b>，表示自己之前是S或者E状态，现在变成了S状态。即peer cache中没有修改过的数据，从内存中获取的数据就是最新的。</li></ul><ul><li><b>Home Agent从Memory获得数据</b>，以及<b>所有的嗅探结束后，才能向最初的请求者发送GO响应</b>。其中，GO消息还附带MESI状态信息，用于指示缓存需要切换到的目标状态。在上面的例子中由于还存起其他的副本，所以返回的是GO-S；</li></ul><h4 id="h4-9">Write</h4><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6862206d58cb8da5c87ed252.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6862206d58cb8da5c87ed252.png" alt=""></a></p><ul><li>CXL设备首先<b>发送RdOwn请求来获得写权限</b>，<b>Home Agent发送SnpInv给所有有副本的缓存</b>。如果peer cache<b>没有脏的数据直接回复RspIHitSE/RspIHitI</b>；如果<b>有脏的数据需要返回RspIFwdM</b>，同时将数据通过D2H Data通道写回去。</li></ul><ul><li>在这个例子中我们看到Home agent把所有的peer cache无效掉，并没有从缓存中获得数据，所以从memory中返回的数据就是最新的。然后发送Go-E和Data给发起者。</li></ul><ul><li><b>CXL设备获得写权限后，进行写入操作，缓存行状态从E变成了M</b>；</li></ul><ul><li>后续<b>这个脏的缓存行</b>可能由于缓存满了需要<b>被替换出去</b>，就需要<b>发送DirtyEvict的写回请求给Home Agent</b>；<b>HomeAgent响应GO_WritePull给CXL设备，表示这个写全局可见了</b>。HomeAgent收到GO_WritePull后就可以安全地把自己的状态改成I状态，同时将数据给到HomeAgent就算完成了。</li></ul><h4 id="h4-10">Read0-Write</h4><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6862207d58cb8da5c87ed2bd.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6862207d58cb8da5c87ed2bd.png" alt=""></a></p><ul><li><b>CXL设备发送ItoMWr/WrCur给Home Agent</b>；<b>Home Agent需要首先负责获取独占权限，然后才能发送GO_writePull</b>，即表示这个写已经全局可见。CXL 设备在收到Go_writePull后就可以把数据直接发送给Home agent；</li></ul><ul><li><b>Home Agent接收到要写入的数据后到底是写到Memory还是推送到peer Cache中；取决于实现，以及当前处理的请求类型</b>。比如MemWr只有在缓存命中的时候才会写入到缓存中，否则直接写到内存中。而ItoMWr只要在memory之前有缓存层级，就会写到缓存中，而不会写到内存中去。</li></ul><h2 id="h2-11">CXL.mem</h2><ul><li>CXL.mem使得host可以使用l<b>oad/store语义</b>访问device上的内存</li></ul><ul><li>CXL.mem 将<b>附着设备的内存纳入一致性系统地址空间，通过共享的全局地址映射实现设备内存与主机内存的统一可见性</b>。这种内存被称为 <b>主机管理设备内存（Host-Managed Device Memory, HDM）</b>，并具有 <b>设备管理一致性</b>（Device Managed Coherence, DMC）。<ul><li>与PDM（Private Device Memory）的区分：</li></ul><ul><li>HDM：纳入全局一致性域，主机可直接访问（如CXL设备内存）。</li></ul><ul><li>PDM：仅设备内部可见，主机无法直接访问（如传统GPGPU的GDDR）。它完全由设备硬件和驱动程序管理，主要用作具有大型数据集的设备的中间存储。当接收操作数并写回结果时，它涉及从 Host 内存到附着设备的内存之间的大量来回复制。</li></ul><ul><li>CXL设备可同时包含HDM和PDM区域。</li></ul></li></ul><p>CXL.mem共有三种一致性模型，分别是<b>HDM-H</b>、<b>HDM-D</b>和<b>HDM-DB</b></p><ul><li><b>HDM-H</b>：仅Type3设备，也就是无CXL.cache，主要作用是用来内存扩展，不存在会修改设备内存中的计算单元，因此设备不会缓存host的内存。</li></ul><ul><li><b>HDM-D</b>：仅Type-2设备，使用CXL.cache维护跟主机的一致性；<ul><li>为了简化HDM-D设备一致性协议的实现，CXL提出了一种称为<b>基于偏置的连贯性模型</b>(Bias Based Coherency Model)。HDM-D设备内存分为两种偏置模型，一种为<b>主机偏置</b>(host Bias)，一种为<b>设备偏置</b>(Device Bias)；</li></ul><ul><li><b>Host Bias</b>：</li></ul><ul><li><b>主机可直接低延迟访问设备内存（类似远端本地内存），加速任务卸载与结果拉取。</b></li></ul><ul><li>设备访问需通过CXL.cache协议向主机请求，确保缓存一致性（如Type 2设备）。</li></ul><ul><li><b>Device Bias</b>：</li></ul><ul><li><b>设备可高带宽访问本地内存，无需与主机交互（无Snoop开销）</b>，因主机保证无缓存副本。</li></ul><ul><li>主机访问需先触发偏置翻转（Bias Flip）（通过缓存冲刷与状态切换），确保一致性后再访问。</li></ul><ul><li>CXL设备也可以不实现偏置模式，那么认为所有的内存都是Host Bias</li></ul></li></ul><ul><li><b>HDM-DB</b>：在CXL3.0后，新增加的一致性模型，可以用于type2/type3设备</li></ul><h3 id="h3-12">协议通道和消息类型</h3><p>在 CXL.cache 中，两端是 Host 和 Device；而 CXL.mem，两端是 <b>Master</b>和<b>Subordinate</b>。</p><p>从 Master 到 Subordinate 的消息（<b>M2S</b>）有三类：</p><ol start="1"><li><b>Request(Req)</b></li></ol><ol start="2"><li><b>Request with Data(RwD)</b></li></ol><ol start="3"><li><b>Back-Invalidation Response(BIRsp)</b>，CXL3.0加入</li></ol><p>从 Subordinate 到 Master 的消息（<b>S2M</b>）有三类：</p><ol start="1"><li><b>Response without data(NDR, No Data Response)</b></li></ol><ol start="2"><li><b>Response with Data(DRS, Data Response)</b></li></ol><ol start="3"><li><b>Back-Invalidation Snoop(BiSnp)</b>，CXL3.0加入</li></ol><h3 id="h3-13">HDM-H</h3><p>在Type 3设备中，H<b>DM-H地址区域用作内存扩展器</b>或用于具有软件一致性的共享FAM设备，其中<b>设备不需要主动管理与主机的一致性</b>。这使得流向HDM-H的事务流可以简化为仅两类，即<b>读取和写入</b>。</p><h4 id="h4-14">Read from Host</h4><p>在此流程中，仅返回一条数据消息。 <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6862209c58cb8da5c87ed38c.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6862209c58cb8da5c87ed38c.png" alt=""></a></p><h4 id="h4-15">Write from Host</h4><p>与读取操作不同，写操作总是以S2M NDR Cmp消息完成。这一通用的写入流程下图： <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/686220aa58cb8da5c87ed3ef.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/686220aa58cb8da5c87ed3ef.png" alt=""></a></p><h3 id="h3-16">HDM-D</h3><h4 id="h4-17">Read from Host</h4><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/686220cf58cb8da5c87ed4eb.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/686220cf58cb8da5c87ed4eb.png" alt=""></a></p><ul><li>其中<b>Dev$表示设备内的缓存，Dev Mem表示附着设备的内存</b>；</li></ul><ul><li><b>Host</b>从M2S方向的Req通道<b>发送MemRd</b>请求，同时包含<b>SnpData</b>，表示Host仅仅想要一个副本，后续不打算修改。<b>DCOH则查找Snoop Filter发现命中，则嗅探自己的缓存</b>。</li></ul><ul><li>嗅探缓存得到数据后通过<b>S2M的NDR通道响应Cmp-S</b>（Host的缓存只能处于S状态），通过S2M的DRS通道响应MemData</li></ul><h4 id="h4-18">Write from Host</h4><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/686220f858cb8da5c87ed6cf.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/686220f858cb8da5c87ed6cf.png" alt=""></a></p><ul><li><b>Host在H2S的RwD通道发送MemWr/MemWrPtl请求</b>，写的数据一并通过这个通道带下来。</li></ul><ul><li><b>DCOH查找SF</b>，嗅探数据的同时<b>将所有设备端的副本无效掉</b>；</li></ul><ul><li>获得嗅探的<b>原始数据后跟需要写入的数据进行合并，然后一起写到设备内存</b>中；</li></ul><ul><li>最后给host在S2H的NDR通道响应一个Cmp表示写入完成；</li></ul><h4 id="h4-19">Device Read to Device Memory</h4><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6862210858cb8da5c87ed78e.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6862210858cb8da5c87ed78e.png" alt=""></a></p><ul><li>如果DCOH确认这个地址<b>处于主机偏置</b>，需要<b>通过CXL.cache发送请求到主机侧来解决缓存一致性</b>（我们知道Type2设备是支持CXL.cache，而处于主机偏执下的设备内存此时对于设备来说就相当于主机内存，所以可以复用CXL.cache协议），先请求Device Bias。</li></ul><ul><li>如果DCOH确认这个地址处于<b>设备偏置</b>，如上图的下半部分，那么<b>直接从本地内存读数据即可</b>。</li></ul><ul><li>当主机侧处理完读请求的一致性后，在这个例子中主机没有修改过的数据（可能是S/E状态），因此它在<b>CXL.mem的M2S Req通道上发送MemRdFwd</b>请求，并携带MetaValue来表示Host端是否还有副本。<b>Host发送的MemRdFwd请求相当于是对设备在CXL.cache D2H Request通道RdAny请求的响应</b>(本来是在CXL.cache 的H2D 响应通道发送Go响应的)，这么做目的是<b>确保后续Host对附着设备内存在CXL.mem M2S通道上发送的请求能够被序列化</b>到该请求的后面，减少了可能的冲突冒险发生。</li></ul><ul><li><b>DCOH在接收到MemRdFwd就代表设备内存中的数据就是最新的</b>。在上面的例子中，Host侧没有修改的数据，所以可以直接发送MemRdFwd请求当作响应；后续的操作就比较简单了，类似于设备偏置的情况。</li></ul><h4 id="h4-20">设备发起的写操作</h4><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6862211a58cb8da5c87ed848.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6862211a58cb8da5c87ed848.png" alt=""></a></p><ul><li>上面的过程其实跟普通的读操作是类似的，只不过发送的请求变成了<b>RdOwn</b>，同时在主机侧所进行的<b>Snoop操作变成了SnpInv</b>，最后返回给DOCH的Metavalue也变成了I。其他的过程都是一样的。<b>主机收到MemRdFwd的响应后会变成设备偏置模式</b>。在<b>设备偏置模式下，设备缓存的写回操作不需要经过Host了</b>，在设备端即可完成。</li></ul><ul><li>如果设备本地端还有其他缓存存在副本，DCOH除了发送请求给Host解决外部的一致性外，还需要负责发送SnpInv去无效设备本地端的缓存副本。在上面例子中由于Host中缓存处于M状态，在设备本地的其他缓存不可能存在副本。</li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/reference" >reference</a></li></ul><ul><li><a href="../../md-docs/CXL_System_Architecture" >CXL_System_Architecture</a></li></ul><ul><li><a href="../../CXL简介/CXL初认识" >CXL简介</a><ul><li><a href="../../CXL简介/CXL初认识" >CXL初认识</a></li></ul><ul><li><a href="../../CXL简介/CXL子协议" >CXL子协议</a></li></ul><ul><li><a href="../../CXL简介/CXL2.0介绍" >CXL2.0介绍</a></li></ul><ul><li><a href="../../CXL简介/CXL3.0介绍" >CXL3.0介绍</a></li></ul><ul><li><a href="../../CXL简介/CXL3.1和CXL3.2" >CXL3.1和CXL3.2</a></li></ul></li></ul><ul><li><a href="../../CXL_Transaction_Layer/CXL.io" >CXL_Transaction_Layer</a><ul><li><a href="../../CXL_Transaction_Layer/CXL.io" >CXL.io</a></li></ul><ul><li><a href="../../CXL_Transaction_Layer/CXL.mem" >CXL.mem</a></li></ul><ul><li><a href="../../CXL_Transaction_Layer/CXL.cache" >CXL.cache</a></li></ul><ul><li><a href="../../CXL_Transaction_Layer/Transaction_Ordering_Summary" >Transaction_Ordering_Summary</a></li></ul><ul><li><a href="../../CXL_Transaction_Layer/Transaction Flows to Device-attached Memory" >Transaction Flows to Device-attached Memory</a></li></ul></li></ul><ul><li><a href="../../Switching/Overview" >Switching</a><ul><li><a href="../../Switching/Overview" >Overview</a></li></ul><ul><li><a href="../../Switching/7.2 Switch Configuration and Composition" >7.2 Switch Configuration and Composition</a></li></ul><ul><li><a href="../../Switching/7.3 CXL.io, CXL.cachemem Decode and Forwarding" >7.3 CXL.io, CXL.cachemem Decode and Forwarding</a></li></ul><ul><li><a href="../../Switching/7.6 Fabric Manager Application Programming Interface" >7.6 Fabric Manager Application Programming Interface</a></li></ul><ul><li><a href="../../Switching/7.7 CXL Fabric Architecture" >7.7 CXL Fabric Architecture</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../CXL简介/CXL初认识","../../CXL简介/CXL2.0介绍","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>