<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/IcarusSong/cxl-introduction.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">Transaction_Ordering_Summary</a><ul><li><a href="#h2-1">通用概念：如何理解排序规则</a></li></ul><ul><li><a href="#h2-2">表格一：上行排序总结 (Table 3-57)</a><ul><li><a href="#h3-3">1. M7 规则 (Yes(4)) 的注释解读</a></li></ul><ul><li><a href="#h3-4">2. E6a 规则 (No(3)) 的注释解读</a></li></ul><ul><li><a href="#h3-5">3. E6b 规则 (Y/N) 的注释解读</a></li></ul><ul><li><a href="#h3-6">表格二：下行排序总结 (Table 3-58)</a><ul><li><a href="#h4-7">1. 规则 G8a 和 G8b：M2S Req 通道内部的排序</a></li></ul><ul><li><a href="#h4-8">2. 规则 H8a 和 H8b：M2S RWD vs M2S Req</a></li></ul><ul><li><a href="#h4-9">3. 规则 I9a 和 I9b：H2D Req vs M2S RWD</a></li></ul><ul><li><a href="#h4-10">4. 规则 I11a 和 I11b：H2D Req vs H2D Rsp</a></li></ul></li></ul><ul><li><a href="#h3-11">表格三：设备进出排序总结 (Table 3-59)</a><ul><li><a href="#h4-12">1. BISnp 的二元性：设备如何“掌控”一致性 (最重要的规则)</a></li></ul><ul><li><a href="#h4-13">2. 响应通道必须“永不拒绝” (核心防死锁原则)</a></li></ul><ul><li><a href="#h4-14">3. CXL.io 与 CXL.mem/cache 的交互</a></li></ul><ul><li><a href="#h4-15">4. P2P 通道的独立性（脚注 ¹）</a></li></ul></li></ul><ul><li><a href="#h3-16">表格四：主机进出排序总结 (Table 3-60)</a></li></ul></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">Transaction_Ordering_Summary</h1><h2 id="h2-1">通用概念：如何理解排序规则</h2><p>在深入每个表格之前，先统一几个基本概念：</p><ul><li><b>视角 (Perspective)</b>：每个表格都有一个独特的“视角”，理解这一点至关重要。</li></ul><ul><li><b>消息顺序</b>：在<b>排序总结表</b>（3-57, 3-58）中，<b>列 (Column)</b> 代表先发出的消息，<b>行 (Row)</b> 代表后发出的消息。表格内容回答的是：“行”消息能否越过“列”消息？</li></ul><ul><li><b>组件依赖</b>：在<b>进出排序表</b>（3-59, 3-60）中，它回答的是：“一个组件（主机或设备）在处理<b>进入</b>的消息（行）时，是否会受到<b>发出</b>的消息（列）的阻塞？” <code>Yes</code> 表示独立、不阻塞；<code>Y/N</code> 表示可以阻塞。</li></ul><ul><li><b>规则含义</b>：<ul><li><b>Yes</b>: <b>必须越过</b>。这是为<b>避免死锁</b>而设的强制规则。</li></ul><ul><li><b>No</b>: <b>禁止越过</b>。这是为<b>保证协议正确性</b>（如一致性）而设的强制规则。</li></ul><ul><li><b>Y/N</b>: <b>可选</b>。协议不作强制要求，由具体实现决定。</li></ul></li></ul><h2 id="h2-2">表格一：上行排序总结 (Table 3-57)</h2><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/686269d858cb8da5c87fa868.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/686269d858cb8da5c87fa868.png" alt=""></a></p><ul><li><b>视角</b>：<b>从 CXL 链路本身出发，看“上行”方向（从设备到主机）的流量。</b></li></ul><ul><li><b>核心问题</b>：“设备发出的不同消息之间，谁可以先走？”</li></ul><ul><li><b>规则解释</b>：<ul><li>Yes(1):CXL架构对ARB/MUX的要求</li></ul><ul><li>Yes(2)：CXL.cachemem：为避免死锁所必需。</li></ul><ul><li>No(3):类型2/3设备，其中BIConflictAck不能在相同地址的先前Cmp*之前通过。</li></ul><ul><li>Yes(4):为避免死锁，引入BISnp通道是必需的。对于CXL.io无序I/O，这是必要的，因为无序I/O可以触发BISnp。</li></ul></li></ul><h3 id="h3-3"><ol start="1"><li>M7 规则 (<code>Yes(4)</code>) 的注释解读</li></ol></h3><ul><li><b>规则</b>：<code>S2M BISnp</code>（设备发起的窥探）<b>必须可以</b>越过 <code>D2H Req</code>（设备发起的读写请求）。</li></ul><ul><li><b>讲解</b>:</li></ul><p>这句注释揭示了 CXL 协议中一个至关重要的<b>防死锁设计</b>。它描述了一个潜在的“依赖关系”链条，如果不打破这个链条，系统就会卡死。</p><ol start="1"><li><p>设备发出一个 <code>D2H Req</code>（比如读内存），它需要等待主机的处理和响应才能完成。</p></li></ol><ol start="2"><li><p>主机为了响应这个 <code>D2H Req</code>，可能需要先向设备发出一个新的 <code>M2S Req</code>（比如获取锁或更新状态）。</p></li></ol><ol start="3"><li><p>然而，如果主机要发的这个 <code>M2S Req</code> 访问的地址，恰好是设备之前一个<i>*尚未完成的 <code>S2M BISnp</code><i>* 的目标地址，那么根据规则，设备必须</i><i>阻塞</i></i>这个 <code>M2S Req</code>。</p></li></ol><p>这样就形成了一个致命的依赖循环： <b><code>D2H Req</code> 等待 <code>M2S Req</code> -&gt; <code>M2S Req</code> 等待 <code>S2M BISnp</code></b></p><p>如果此时 <code>S2M BISnp</code> 也必须排在 <code>D2H Req</code> 后面，那就形成了 <i>*<code>S2M BISnp</code> 等待 <code>D2H Req</code><i>* 的局面，最终导致 </i><i>A-&gt;B-&gt;C-&gt;A</i></i> 的死锁。</p><p>因此，M7 规则通过强制 <code>S2M BISnp</code> 拥有越过 <code>D2H Req</code> 的“特权”，直接斩断了这个依赖链的最后一环，从而避免了死锁。</p><h3 id="h3-4"><ol start="2"><li>E6a 规则 (<code>No(3)</code>) 的注释解读</li></ol></h3><ul><li><b>规则</b>：在 <code>S2M NDR</code> 通道内部，<code>BIConflictAck</code> 消息<b>绝不能</b>越过发往同一地址的 <code>Cmp*</code>（完成）消息。</li></ul><ul><li><b>讲解</b>:</li></ul><p>这是一个保证<b>协议正确性</b>的严格排序规则，专门用于 <code>BISnp</code> 的<b>冲突处理</b>流程。 当主机检测到它发出的 <code>M2S Req</code> 与收到的 <code>S2M BISnp</code> 发生地址冲突时，它需要判断这是一个“早期冲突”（<code>M2S Req</code> 未被设备处理）还是“晚期冲突”（<code>M2S Req</code> 已被设备处理）。</p><p>判断的<b>唯一依据</b>就是 <code>Cmp*</code>（对 <code>M2S Req</code> 的完成响应）和 <code>BIConflictAck</code>（对冲突的确认响应）的<b>先后到达顺序</b>。</p><p>如果允许 <code>BIConflictAck</code> 越过 <code>Cmp*</code>，那么主机收到的顺序将是混乱的、不可信的，它将无法做出正确的判断，从而导致一致性被破坏。因此，E6a 规则强制这两者必须按设备发出的顺序排队，以保证冲突处理机制的正确运作。</p><h3 id="h3-5"><ol start="3"><li>E6b 规则 (<code>Y/N</code>) 的注释解读</li></ol></h3><ul><li><b>规则</b>：除了 E6a 描述的特定情况外，<code>S2M NDR/DRS</code> 通道内的其他消息之间没有强制排序要求。</li></ul><ul><li><b>讲解</b>:</li></ul><p>这条规则为性能优化提供了<b>灵活性</b>。它意味着，只要不涉及 E6a 中的那种特殊冲突处理场景，那么：</p><ul><li>一个对地址 A 的完成消息，可以越过一个对地址 B 的完成消息。</li></ul><ul><li>一个对地址 C 的数据响应，也可以越过对地址 D 的数据响应。</li></ul><p>这种乱序处理能力有助于提高链路资源的利用率，提升系统整体吞吐量。</p><h3 id="h3-6">表格二：下行排序总结 (Table 3-58)</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/68626be958cb8da5c87fb1fe.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/68626be958cb8da5c87fb1fe.png" alt=""></a></p><ul><li><b>视角</b>：<b>从 CXL 链路本身出发，看“下行”方向（从主机到设备）的流量。</b></li></ul><ul><li><b>核心问题</b>：“主机发出的不同消息之间，谁可以先走？”</li></ul><ul><li><b>规则解释</b>：<ul><li>Yes(1): CXL架构对ARB/MUX的要求。</li></ul><ul><li>Yes(2): CXL.cachemem：为避免死锁所必需。</li></ul><ul><li>Yes(3): CXL.cachemem：性能优化。</li></ul><ul><li>Y/N(3): CXL.cachemem：为性能优化推荐非阻塞。</li></ul><ul><li>No(4): 类型1/2设备：窥探推送GO要求。</li></ul><ul><li>No(5): 类型2设备：MemRd* /MemInv* 推送Mem* Fwd*要求。</li></ul><ul><li>Yes(6): 为避免死锁，引入BISnp通道是必需的。</li></ul></li></ul><h4 id="h4-7"><ol start="1"><li>规则 G8a 和 G8b：<code>M2S Req</code> 通道内部的排序</li></ol></h4><ul><li><b>规则 G8a (<code>No(5)</code>) 的详细解读</b>:<ul><li><b>核心规则</b>: 主机的读/无效化请求 (<code>MemRd*/MemInv*</code>) <b>绝不能</b>越过发往同一地址的 <code>Mem*Fwd</code> 消息。</li></ul><ul><li><b>适用范围非常精确</b>:</li></ul><ol start="1"><li><p><b>仅适用于 HDM-D 模型</b>：这条规则是为解决 HDM-D 模型下的竞态条件而设计的。因为只有在这个模型下，设备才会通过 CXL.cache 发请求，并收到主机返回的 <code>Mem*Fwd</code> 响应。</p></li></ol><ol start="2"><li><p><b>HDM-DB 模型不适用</b>：使用 <code>BISnp</code> 通道的 HDM-DB 模型，其一致性流程完全不同，不使用 <code>Mem*Fwd</code>，因此这条规则不适用。</p></li></ol><ol start="3"><li><p><b>无 HDM-D 的 Type 3 设备不适用</b>：同理，一个纯粹的内存扩展设备（Type 3）如果没有 HDM-D 区域，也无需实现此规则。</p></li></ol><ul><li><b>总结</b>: G8a 是一个针对<b>特定场景（HDM-D）</b>的<b>协议正确性</b>规则，确保主机的新请求不会干扰设备正在处理的、与 CXL.cache 相关的旧事务。</li></ul></li></ul><ul><li><b>规则 G8b (<code>Y/N</code>) 的详细解读</b>:<ul><li><b>核心规则</b>: 除了 G8a 的特定情况外，<code>M2S Req</code> 通道内的其他消息之间没有强制排序要求。</li></ul><ul><li><b>总结</b>: 这意味着，对于发往不同地址的请求，或者在不涉及 <code>Mem*Fwd</code> 的情况下，协议允许乱序处理以提升性能。</li></ul></li></ul><h4 id="h4-8"><ol start="2"><li>规则 H8a 和 H8b：<code>M2S RWD</code> vs <code>M2S Req</code></li></ol></h4><ul><li><b>规则 H8a (<code>Yes(6)</code>) 的详细解读</b>:<ul><li><b>核心规则</b>: 对于<b>支持 BISnp 的设备</b>，主机的写请求 (<code>M2S RWD</code>) <b>必须可以</b>越过读请求 (<code>M2S Req</code>)。</li></ul><ul><li><b>为何如此？</b>：这是一个关键的<b>防死锁</b>规则。<code>BISnp</code> 机制可能会导致 <code>M2S Req</code> 通道被阻塞。如果 <code>M2S Req</code> 又阻塞了 <code>M2S RWD</code>，就可能形成死锁。H8a 强制写通道独立，确保其总能“排空”，从而打破了这种潜在的依赖。</li></ul></li></ul><ul><li><b>规则 H8b (<code>Y/N</code>) 的详细解读</b>:<ul><li><b>核心规则</b>: 对于<b>不支持 BISnp 的设备</b>，<code>M2S RWD</code> 和 <code>M2S Req</code> 之间的排序是可选的。</li></ul><ul><li><b>为何如此？</b>：因为不存在由 <code>BISnp</code> 引发的死锁风险，所以协议放宽了限制，给予了实现上的灵活性。</li></ul></li></ul><h4 id="h4-9"><ol start="3"><li>规则 I9a 和 I9b：<code>H2D Req</code> vs <code>M2S RWD</code></li></ol></h4><ul><li><b>规则 I9a (<code>Yes(2)</code>) 的详细解读</b>:<ul><li><b>核心规则</b>: 在特定高级拓扑中（如支持 PBR 的交换机、交换机间链路、P2P 设备），Snoop 请求 (<code>H2D Req</code>) <b>必须可以</b>越过写请求 (<code>M2S RWD</code>)。</li></ul><ul><li><b>为何如此？</b>：这可能同样是为避免在更复杂的 fabric 拓扑（如 P2P 通信）中可能出现的、更微妙的死锁或资源竞争问题而设计的。</li></ul></li></ul><ul><li><b>规则 I9b (<code>Y/N</code>) 的详细解读</b>:<ul><li><b>核心规则</b>: 在常规的、非 P2P 的简单拓扑中，这两者间的排序是可选的。</li></ul></li></ul><h4 id="h4-10"><ol start="4"><li>规则 I11a 和 I11b：<code>H2D Req</code> vs <code>H2D Rsp</code></li></ol></h4><ul><li><b>规则 I11a (<code>No(4)</code>) 的详细解读</b>:<ul><li><b>核心规则</b>: Snoop 请求 (<code>H2D Req</code>) <b>绝不能</b>越过发往同一地址的 <code>GO*</code> 消息。</li></ul><ul><li><b>重要的实现细节</b>: 注释特别强调，<code>GO</code> 消息本身<b>不携带地址</b>。地址信息需要通过 <code>GO</code> 消息中的 <code>UQID</code> 来间接推断。如果一个系统的实现<b>无法</b>通过 <code>UQID</code> 可靠地推断出地址，那么为了绝对安全，它就必须采用最严格的策略：<b>任何 Snoop 都不能越过任何 GO 消息</b>，无论它们的地址是否相同。这极大地增加了对保序的要求，是保证协议正确性的一个重要实现考量。</li></ul></li></ul><ul><li><b>规则 I11b (<code>Y/N</code>) 的详细解读</b>:<ul><li><b>核心规则</b>: 如果不属于 I11a 的情况（例如，可以明确区分 Snoop 和 GO 的地址不同），则排序是可选的。</li></ul></li></ul><h3 id="h3-11">表格三：设备进出排序总结 (Table 3-59)</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6862723658cb8da5c87fd477.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6862723658cb8da5c87fd477.png" alt=""></a></p><ul><li><b>视角</b>：<b>从 CXL 设备的内部逻辑出发。</b></li></ul><ul><li><b>核心问题</b>：“如果我（设备）正准备发出一个消息（列），但被阻塞了，我能否继续处理一个刚收到的消息（行）？” <code>Yes</code> 意味着可以继续处理，两者相互独立。<ul><li>Yes：代表“独立”。收到的消息（行）必须能被处理，不能依赖于被卡住的发出消息（列）。这是避免死锁的强制规则。</li></ul><ul><li>Y/N：代表“可以依赖”。协议允许设备在处理收到的消息（行）时，等待那个被卡住的发出消息（列）。这意味着设备可以阻塞收到的消息。</li></ul></li></ul><ul><li>Yes(1)：CXLcachemem 与发出的 CXLio 流量无关</li></ul><ul><li>Y/N(1)：除了UIO Completion 之外，CXLio 流量可能会被 CXLcachemem 阻塞</li></ul><ul><li>Yes(2)：CXLcachemem：避免死锁所必需</li></ul><ul><li>Yes(3)：CXL UIO completion 与 CXLcachemem 无关</li></ul><h4 id="h4-12"><ol start="1"><li>BISnp 的二元性：设备如何“掌控”一致性 (最重要的规则)</li></ol></h4><p>表格中最关键的规则体现在对 <code>S2M BISnp</code>（列 M）的处理上，它完美展示了协议如何在“阻塞以保证正确性”和“放行以避免死锁”之间取得平衡。</p><ul><li><b>规则 (行 8, 列 M -&gt; <code>Y/N</code>)：允许阻塞主机读请求</b><ul><li><b>内容</b>：当设备准备发出 <code>S2M BISnp</code> 时，它<b>可以</b>暂停处理新收到的主机<b>读请求 (<code>M2S Req</code>)</b>。</li></ul><ul><li><b>讲解</b>：这是设备对主机实施一致性管理的<b>主动“刹车”机制</b>。当设备需要通过 <code>BISnp</code> 收回主机对某个地址的缓存权限时，它必须能阻止主机在此时对该地址发起新的读取或无效化操作。<code>Y/N</code> 赋予了设备这个<b>阻塞的权力</b>，是保证一致性操作原子性的关键。</li></ul></li></ul><ul><li><b>规则 (行 9, 列 M -&gt; <code>Yes(2)</code>)：必须放行主机写请求</b><ul><li><b>内容</b>：当设备准备发出 <code>S2M BISnp</code> 时，它<b>绝不能</b>阻塞新收到的主机<b>写请求 (<code>M2S RWD</code>)</b>。</li></ul><ul><li><b>讲解</b>：这是一个至关重要的<b>防死锁规则</b>。CXL 协议要求写数据通道必须始终保持畅通。如果 <code>BISnp</code> 阻塞了写请求 <code>M2S RWD</code>，而 <code>BISnp</code> 的完成又可能依赖于主机的一次写回（其本身也是一个 <code>M2S RWD</code> 事务），就会形成致命的依赖循环。因此，协议强制规定 <code>M2S RWD</code> 的处理独立于 <code>BISnp</code> 的发送。</li></ul></li></ul><h4 id="h4-13"><ol start="2"><li>响应通道必须“永不拒绝” (核心防死锁原则)</li></ol></h4><ul><li><b>规则 (例如 行 11, 列 F -&gt; <code>Yes(2)</code>)：接收响应独立于发送请求</b><ul><li><b>内容</b>：设备在处理<b>收到的响应</b>（如 <code>H2D Rsp</code>、<code>H2D Data</code>）时，<b>绝不能</b>依赖于<b>发出的请求</b>（如 <code>D2H Req</code>、<code>S2M BISnp</code>）是否被阻塞。</li></ul><ul><li><b>讲解</b>：这是经典的资源死锁预防设计。想象一下，如果设备因为要发送一个请求（但被卡住）而无法接收响应，而它要发送的这个请求又恰好需要等待这个响应来释放内部资源（如一个事务跟踪器），那么设备就会彻底卡死。<code>Yes(2)</code> 规则强制要求接收响应的逻辑和资源（如缓冲区）必须与发送请求的逻辑和资源<b>相互独立</b>，从而打破这种依赖。</li></ul></li></ul><h4 id="h4-14"><ol start="3"><li>CXL.io 与 CXL.mem/cache 的交互</li></ol></h4><ul><li><b>规则 (行 2-5, 列 E/F/M)</b>：<ul><li><b><code>Y/N(1)</code><b>：进入设备的 CXL.io 流量（如一个新的 PIO 请求）</b>可以</b>被设备正在发出的 CXL.mem/cache 流量阻塞。这允许实现者对不同协议的流量进行优先级排序。</li></ul><ul><li><b><code>Yes(3)</code><b>：这是一个重要的例外。进入设备的 </b>UIO 完成信号</b>必须独立于 CXL.mem/cache 流量。这意味着，即使设备的其他发送通道被阻塞，它也必须能将 UIO 的完成信号发出去。这可能是为了防止 I/O 操作因内存侧的拥塞而超时。</li></ul></li></ul><h4 id="h4-15"><ol start="4"><li>P2P 通道的独立性（脚注 ¹）</li></ol></h4><ul><li><b>规则 (例如 行 8, 列 N -&gt; <code>Yes(2)</code>)</b><ul><li><b>内容</b>：对于支持直接 P2P CXL.mem 的设备，其处理标准主机请求（如 <code>M2S Req</code>，行 8）的逻辑必须独立于它自己作为发起方去访问对等设备的请求（如 P2P <code>M2S Req</code>，列 N）。</li></ul><ul><li><b>讲解</b>：这确保了设备在扮演“<b>从属方</b>”（响应主机）和“<b>主控方</b>”（访问对等设备）两种角色时，两种角色的数据流不会相互阻塞，保证了两种通信都能正常进行。</li></ul></li></ul><p><b>总结</b>：表格 3-59 是 CXL <b>设备实现者</b>的重要参考。它从设备内部的视角，通过一系列强制独立 (<code>Yes</code>) 和可选依赖 (<code>Y/N</code>) 的规则，精确地定义了处理不同输入输出消息时的资源依赖关系，其核心目标是在赋予设备必要的一致性管理能力的同时，严防任何可能导致内部逻辑卡顿或系统死锁的依赖环路。</p><h3 id="h3-16">表格四：主机进出排序总结 (Table 3-60)</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/6862746058cb8da5c87fdced.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/6862746058cb8da5c87fdced.png" alt=""></a></p><ul><li><b>视角</b>：<b>从 CXL 主机的内部逻辑出发。</b></li></ul><ul><li><b>核心问题</b>：“如果我（主机）正准备发出一个消息（列），但被阻塞了，我能否继续处理一个刚收到的消息（行）？”</li></ul><ul><li><b>关键规则解读</b>：<ol start="1"><li><p><b>主机必须能接收一切</b>：绝大部分规则都是 <code>Yes</code> 或 <code>Y/N</code>。这体现了一个原则：主机作为系统的核心，必须有能力随时处理来自设备的各种上行消息（响应、请求、窥探等），即使自己下行的通道被阻塞了。</p></li></ol><ol start="2"><li><p><b>处理 BISnp 的高优先级</b>：进入主机的 <code>S2M BISnp</code> (行 13) 几乎独立于主机正要发出的所有消息。这确保了主机能够及时响应设备发起的一致性管理请求，这是整个 HDM-DB 模型能正常工作的前提。</p></li></ol><ol start="3"><li><p><b>处理响应的高优先级</b>：进入主机的各种响应（<code>S2M NDR/DRS</code>, <code>D2H Rsp/Data</code>） (行 6) 也必须被处理，这能帮助主机释放其内部为请求分配的跟踪资源，并让设备端也能释放相应资源。</p></li></ol></li></ul><p><b>总结</b>：这四个表格从<b>链路（上行/下行）</b>和<b>端点（主机/设备）</b>两个维度、四个不同视角，共同构建了一套完整而严密的 CXL 事务排序模型。它们协同工作，通过强制的“禁止越过”来保证<b>协议正确性</b>，通过强制的“必须越过”来<b>避免死锁</b>，并通过“可选越过”为高性能实现提供了<b>灵活性</b>。</p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../md-docs/reference" >reference</a></li></ul><ul><li><a href="../../md-docs/CXL_System_Architecture" >CXL_System_Architecture</a></li></ul><ul><li><a href="../../CXL简介/CXL初认识" >CXL简介</a><ul><li><a href="../../CXL简介/CXL初认识" >CXL初认识</a></li></ul><ul><li><a href="../../CXL简介/CXL子协议" >CXL子协议</a></li></ul><ul><li><a href="../../CXL简介/CXL2.0介绍" >CXL2.0介绍</a></li></ul><ul><li><a href="../../CXL简介/CXL3.0介绍" >CXL3.0介绍</a></li></ul><ul><li><a href="../../CXL简介/CXL3.1和CXL3.2" >CXL3.1和CXL3.2</a></li></ul></li></ul><ul><li><a href="../../CXL_Transaction_Layer/CXL.io" >CXL_Transaction_Layer</a><ul><li><a href="../../CXL_Transaction_Layer/CXL.io" >CXL.io</a></li></ul><ul><li><a href="../../CXL_Transaction_Layer/CXL.mem" >CXL.mem</a></li></ul><ul><li><a href="../../CXL_Transaction_Layer/CXL.cache" >CXL.cache</a></li></ul><ul><li><a href="../../CXL_Transaction_Layer/Transaction_Ordering_Summary" >Transaction_Ordering_Summary</a></li></ul><ul><li><a href="../../CXL_Transaction_Layer/Transaction Flows to Device-attached Memory" >Transaction Flows to Device-attached Memory</a></li></ul></li></ul><ul><li><a href="../../Switching/Overview" >Switching</a><ul><li><a href="../../Switching/Overview" >Overview</a></li></ul><ul><li><a href="../../Switching/7.2 Switch Configuration and Composition" >7.2 Switch Configuration and Composition</a></li></ul><ul><li><a href="../../Switching/7.3 CXL.io, CXL.cachemem Decode and Forwarding" >7.3 CXL.io, CXL.cachemem Decode and Forwarding</a></li></ul><ul><li><a href="../../Switching/7.6 Fabric Manager Application Programming Interface" >7.6 Fabric Manager Application Programming Interface</a></li></ul><ul><li><a href="../../Switching/7.7 CXL Fabric Architecture" >7.7 CXL Fabric Architecture</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../CXL_Transaction_Layer/CXL.cache","../../CXL_Transaction_Layer/Transaction Flows to Device-attached Memory","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>