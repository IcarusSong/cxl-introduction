
# 9.6 缓存管理 (Cache Management)

这一节主要解决一个核心问题：主机软件（Host Software）如何能以一种标准化的方式，确保一个 CXL.cache 设备里的缓存被完全清空（即所有缓存行都被写回并置为无效），而又不必重置整个设备。


## 1. 问题的根源：为何需要专门的缓存管理机制？

在传统的计算机体系结构中，CPU 可以通过指令（如 `WBINVD`）来刷新自己的缓存。但是，对于一个独立的 CXL 设备（如智能网卡或加速器）上的缓存，情况变得复杂。

* **CPU 指令的局限性:** 规范明确警告，软件**不能**假设 CPU 的缓存刷新指令会自动刷新 CXL 设备中缓存的、映射到设备端内存 (HDM) 的数据。不同主机的实现可能不同，依赖 CPU 指令会导致不可预测的行为。
* **FLR 的局限性:** 正如 9.5 节所述，功能级重置 (FLR) **不被要求**清除设备缓存。因此，仅靠 FLR 无法达到清空缓存的目的。

这就产生了一个需求：系统软件需要一种可靠、标准化的方法来控制 CXL 设备的缓存，例如在热移除设备或执行 CXL Reset 之前，以确保数据一致性。

## 2. CXL 的解决方案：专用的缓存写回与失效能力

为了解决上述问题，CXL 规范定义了一套专用的、由软件驱动的缓存管理能力。

* **强制性要求:** 这个能力对于所有支持 CXL.cache 的设备都是**强制性**的，只有一个例外：eRCDs（增强型中继器），对于它们是**强烈推荐**的。
* **能力发现:** 主机软件可以通过检查 CXL DVSEC 寄存器中的 `Cache Writeback and Invalidate Capable` 标志位来判断设备是否支持此功能。

## 3. 软件操作流程：三步清空缓存

要清空设备缓存，软件必须严格遵循以下三个步骤：

1. **设置 `Disable Caching = 1` (禁用缓存)**
    * 软件首先要向设备的 `DVSEC CXL Control2` 寄存器写入，将 `Disable Caching` 位置为 1。
    * **目的:** 这一步是为了阻止在清空缓存的过程中，有新的数据被缓存进来，保证操作的原子性。

2. **设置 `Initiate Cache Write Back and Invalidation = 1` (启动写回与失效)**
    * 接着，软件需要将同一个 `DVSEC CXL Control2` 寄存器中的 `Initiate Cache Write Back and Invalidation` 位置为 1。
    * **目的:** 这个操作会正式触发设备硬件开始将其内部缓存中所有的“脏”数据（被修改过的数据）写回到主机内存，并将所有缓存行置为无效状态。
    * **注意:** 规范允许将第 1 步和第 2 步合并为对 `Control2` 寄存器的一次写操作。

3. **等待 `Cache Invalid = 1` (等待操作完成)**
    * 在发送命令后，软件必须轮询设备的 `DVSEC CXL Status2` 寄存器，直到 `Cache Invalid` 标志位变为 1。
    * **目的:** `Cache Invalid` 位变为 1，是设备发出的“操作已完成”的信号。此时软件可以确定设备缓存已经被完全清空。
    * **实现提示:** 软件在等待时不应无限期地等待。规范建议，软件可以读取设备报告的缓存大小（在 `DVSEC CXL Capability2` 寄存器中），并据此计算出一个合理的超时时间。

## 4. 如何重新启用缓存

在缓存被清空后，如果需要重新使用，软件只需执行一步操作：

* 将 `DVSEC CXL Control2` 寄存器中的 `Disable Caching` 位清零（即写入 0）。
* 当设备硬件检测到 `Disable Caching` 位从 1 变为 0 时，它会自动将 `Cache Invalid` 状态位也清零，表示缓存现在可以重新开始工作了。


### 总结

**9.6 节** 的核心是为 CXL.cache 设备的缓存管理提供了一个**标准化的、由软件驱动的流程**。由于传统的 CPU 指令或 PCIe FLR 机制无法可靠地完成这项任务，CXL 设计了这套专用的“**禁用-启动-等待**”三步法。这个机制对于确保系统在进行热插拔、设备重置或其它关键状态转换时的**数据一致性**至关重要，是所有 CXL 系统软件和设备驱动必须正确实现的关键功能之一。